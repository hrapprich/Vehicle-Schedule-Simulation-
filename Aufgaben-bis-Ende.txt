offene Punkte:
(x) Einleseroutine für gegebene Daten fertigstellen (svenno)
(x) Dokumentation über benötigte Daten für Simulation (Dictionarys beschreiben)
(x) Daten für Störungen aus GUI-Eingabe ziehen
(x) Entscheidung dem Benutzer offen lassen: Pufferzeiten für Abbau Verspätungen nutzen oder nicht (chris)
(x) In Output Verspätungsursache aufnehmen (vlt durch Klassifikation und Ausgabe einer Zahl)
(x) Störungen auf drei Ebenen: Einzelfahrt, Strecke/Umkreis, Global (chris)
(x) Stau einfügen (gehört zu Störebene Strecke)
(x) smartere Stau-Funktion mit dynamischen Vorkommen
(x) Staus lokalisieren
(x) Verspätungen in relative Werte umwandeln
(x) mehr und validere Störungsarten
(x) "Interface" für Störungen
(x) Funktionen verschachteln (Grundfunktionen (wie z.B. Stau), die von Spezialfunktionen getriggert werden)
(x) GUI optimieren/verschönern
(x) Störungen aufräumen und mit GUI verknüpfen

Prioliste:
( ) KPIs einfügen
( ) Störungen zum Laufen bringen
( ) Fahrerstörungen raus

( ) wieviele Fahrzeuge haben nur einen Teilumlauf? hier wirken dispositive Entscheidungen nicht
( ) Event mit Zeitspanne, die man in GUI festlegen kann
( ) Unfall an bestimmter HS (auch wenn rdm bestimmt) muss alle Fahrzeuge beeinflussen, die dort vorbeifahren & die Dauer des daraus resultierenden Staus liegt zwischen x und y (rdmStau-Funktion zum Teil verwenden)
( ) Prioliste erstellen (was muss bis wann stehen?)
( ) Störungsursache für Pausen removen
( ) dispositive Entscheidungen für Verspätungen (z.B. wann Teilumlauf abbrechen) 
( ) Möglichkeit, eine Fahrt überspringen, einbauen
( ) Staufunktion auskommentieren
( ) Simulationsdauer auf eine Woche ausweiten
( ) Dokumentation über tablefinal.csv (svenno)
( ) Dateninkonsistenzen ausbessern
( ) Output für KPIs (PK3)
( ) Code objektorientiert gestalten

( ) Personaldaten konzeptionell mitdenken bzw. Schnittstelle einfügen

( ) PK1 Paper lesen / Fokus auf Suchprozess




